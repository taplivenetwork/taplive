## æ ¹ç›®å½•æ–‡ä»¶

>>>BEGIN FILE: package.json
{
  "name": "taplive-mvp",
  "version": "1.0.0",
  "description": "TapLive MVP - åŸºäº LBS çš„å…¨çƒè§†é¢‘ç›´æ’­ç‚¹æ’­è°ƒåº¦å¹³å°",
  "scripts": {
    "dev": "concurrently \"npm run backend:dev\" \"npm run frontend:dev\"",
    "backend:dev": "cd backend && npm run dev",
    "frontend:dev": "cd frontend && npm run dev",
    "install:all": "npm install && cd backend && npm install && cd ../frontend && npm install",
    "build": "cd frontend && npm run build",
    "lint": "eslint . --ext .ts,.tsx",
    "lint:fix": "eslint . --ext .ts,.tsx --fix",
    "format": "prettier --write \"**/*.{ts,tsx,js,jsx,json,md}\""
  },
  "devDependencies": {
    "@typescript-eslint/eslint-plugin": "^6.0.0",
    "@typescript-eslint/parser": "^6.0.0",
    "concurrently": "^8.2.0",
    "eslint": "^8.45.0",
    "eslint-config-prettier": "^8.8.0",
    "eslint-plugin-prettier": "^5.0.0",
    "eslint-plugin-react": "^7.32.2",
    "eslint-plugin-react-hooks": "^4.6.0",
    "prettier": "^3.0.0",
    "typescript": "^5.0.2"
  },
  "keywords": ["live-streaming", "lbs", "mvp"],
  "author": "TapLive Team",
  "license": "MIT"
}
>>>END FILE

>>>BEGIN FILE: .gitignore
# Dependencies
node_modules/
*/node_modules/

# Production builds
dist/
build/
*/dist/
*/build/

# Environment variables
.env
.env.local
.env.development.local
.env.test.local
.env.production.local
*/.env
*/.env.local

# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Coverage directory used by tools like istanbul
coverage/
*.lcov

# nyc test coverage
.nyc_output

# ESLint cache
.eslintcache

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Microbundle cache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

# Next.js build output
.next

# Nuxt.js build / generate output
.nuxt
dist

# Storybook build outputs
.out
.storybook-out

# Temporary folders
tmp/
temp/

# Editor directories and files
.vscode/
.idea/
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

# OS generated files
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db
>>>END FILE

>>>BEGIN FILE: .eslintrc.js
module.exports = {
  root: true,
  env: {
    browser: true,
    es2020: true,
    node: true,
  },
  extends: [
    'eslint:recommended',
    '@typescript-eslint/recommended',
    'plugin:react/recommended',
    'plugin:react-hooks/recommended',
    'prettier',
  ],
  ignorePatterns: ['dist', '.eslintrc.js'],
  parser: '@typescript-eslint/parser',
  plugins: ['react-refresh', '@typescript-eslint'],
  rules: {
    'react-refresh/only-export-components': [
      'warn',
      { allowConstantExport: true },
    ],
    '@typescript-eslint/no-unused-vars': 'error',
    '@typescript-eslint/no-explicit-any': 'warn',
    'react/react-in-jsx-scope': 'off',
  },
  settings: {
    react: {
      version: 'detect',
    },
  },
}
>>>END FILE

>>>BEGIN FILE: .prettierrc
{
  "semi": false,
  "trailingComma": "es5",
  "singleQuote": true,
  "printWidth": 80,
  "tabWidth": 2,
  "useTabs": false
}
>>>END FILE

>>>BEGIN FILE: README.md
# TapLive MVP

åŸºäº LBS çš„å…¨çƒè§†é¢‘ç›´æ’­ç‚¹æ’­è°ƒåº¦å¹³å°æœ€å°å¯è¡Œäº§å“

## é¡¹ç›®æ¦‚è¿°

TapLive æ˜¯ä¸€ä¸ªåˆ›æ–°çš„ç›´æ’­å¹³å°ï¼Œå…è®¸ç”¨æˆ·å‘èµ·ä½ç½®ç›¸å…³çš„ç›´æ’­è®¢å•ï¼ŒæœåŠ¡è€…å¯ä»¥æ¥å•å¹¶æä¾›ç›´æ’­æœåŠ¡ã€‚

### æ ¸å¿ƒåŠŸèƒ½

- **è®¢å•ç³»ç»Ÿ**: æ”¯æŒå•äººä»˜è´¹å’Œæ‹¼å›¢æ¨¡å¼
- **æ¥å•ç³»ç»Ÿ**: æœåŠ¡è€…æµè§ˆå’Œæ¥å•åŠŸèƒ½
- **ç›´æ’­å›æ”¾**: åŸºç¡€ç›´æ’­å’Œå›æ”¾åŠŸèƒ½
- **åœ°å›¾é€‰ç‚¹**: LBS ä½ç½®é€‰æ‹©
- **ç”¨æˆ·è®¤è¯**: Supabase Auth é›†æˆ

## æŠ€æœ¯æ ˆ

- **åç«¯**: Node.js + Express + TypeScript
- **å‰ç«¯**: Vite + React + TypeScript + Tailwind CSS
- **æ•°æ®åº“**: PostgreSQL / Supabase
- **åœ°å›¾**: Leaflet + OpenStreetMap

## å¿«é€Ÿå¼€å§‹

### æœ¬åœ°å¼€å‘

```bash
# 1. å®‰è£…æ‰€æœ‰ä¾èµ–
npm run install:all

# 2. é…ç½®ç¯å¢ƒå˜é‡
cp backend/.env.example backend/.env
cp frontend/.env.example frontend/.env

# 3. å¯åŠ¨å¼€å‘æœåŠ¡å™¨ï¼ˆåŒæ—¶å¯åŠ¨å‰åç«¯ï¼‰
npm run dev

# æˆ–åˆ†åˆ«å¯åŠ¨
npm run backend:dev   # åç«¯: http://localhost:5174
npm run frontend:dev  # å‰ç«¯: http://localhost:5173
```

### Replit éƒ¨ç½²

1. Fork æœ¬é¡¹ç›®åˆ° Replit
2. åœ¨ Replit Shell ä¸­è¿è¡Œï¼š
```bash
npm run install:all
```
3. åœ¨ Secrets ä¸­é…ç½®ç¯å¢ƒå˜é‡
4. è¿è¡Œ `npm run dev`

## ç¯å¢ƒå˜é‡é…ç½®

å‚è€ƒ `.env.example` æ–‡ä»¶é…ç½®å¿…è¦çš„ç¯å¢ƒå˜é‡ã€‚

## é¡¹ç›®éªŒè¯

1. è®¿é—® http://localhost:5173
2. ç‚¹å‡»"åˆ›å»ºè®¢å•"
3. å¡«å†™è®¢å•ä¿¡æ¯å¹¶æäº¤
4. æŸ¥çœ‹è®¢å•åˆ—è¡¨ç¡®è®¤è®¢å•å·²åˆ›å»º
5. æ£€æŸ¥åç«¯å¥åº·çŠ¶æ€: http://localhost:5174/healthz

## API æ–‡æ¡£

- `GET /healthz` - å¥åº·æ£€æŸ¥
- `GET /api/orders` - è·å–è®¢å•åˆ—è¡¨
- `POST /api/orders` - åˆ›å»ºæ–°è®¢å•

## å¼€å‘è§„èŒƒ

- ä½¿ç”¨ TypeScript ä¸¥æ ¼æ¨¡å¼
- éµå¾ª ESLint + Prettier ä»£ç è§„èŒƒ
- Commit ä¿¡æ¯ä½¿ç”¨ Conventional Commits æ ¼å¼

## License

MIT
>>>END FILE

## åç«¯æ–‡ä»¶

>>>BEGIN FILE: backend/package.json
{
  "name": "taplive-backend",
  "version": "1.0.0",
  "description": "TapLive MVP Backend",
  "main": "dist/server.js",
  "scripts": {
    "dev": "tsx watch server.ts",
    "build": "tsc",
    "start": "node dist/server.js",
    "lint": "eslint src/**/*.ts",
    "lint:fix": "eslint src/**/*.ts --fix"
  },
  "dependencies": {
    "@supabase/supabase-js": "^2.38.0",
    "cors": "^2.8.5",
    "dotenv": "^16.3.1",
    "express": "^4.18.2",
    "helmet": "^7.0.0",
    "joi": "^17.9.2",
    "morgan": "^1.10.0",
    "uuid": "^9.0.0"
  },
  "devDependencies": {
    "@types/cors": "^2.8.13",
    "@types/express": "^4.17.17",
    "@types/morgan": "^1.9.4",
    "@types/node": "^20.4.5",
    "@types/uuid": "^9.0.2",
    "tsx": "^3.12.7",
    "typescript": "^5.1.6"
  }
}
>>>END FILE

>>>BEGIN FILE: backend/tsconfig.json
{
  "compilerOptions": {
    "target": "ES2020",
    "lib": ["ES2020"],
    "module": "CommonJS",
    "moduleResolution": "node",
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "declaration": true,
    "outDir": "./dist",
    "rootDir": "./",
    "resolveJsonModule": true,
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,
    "noImplicitAny": true,
    "noImplicitReturns": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true
  },
  "include": ["src/**/*", "server.ts"],
  "exclude": ["node_modules", "dist"]
}
>>>END FILE

>>>BEGIN FILE: backend/.env.example
# æœåŠ¡å™¨é…ç½®
PORT=5174
NODE_ENV=development

# æ•°æ®åº“é…ç½®ï¼ˆé€‰æ‹©ä¸€ç§ï¼‰
# æœ¬åœ° PostgreSQL
DATABASE_URL=postgresql://username:password@localhost:5432/taplive

# æˆ–è€…ä½¿ç”¨ Supabase
SUPABASE_URL=https://your-project.supabase.co
SUPABASE_ANON_KEY=your-anon-key
SUPABASE_SERVICE_KEY=your-service-key

# CORS é…ç½®
FRONTEND_URL=http://localhost:5173

# æ—¥å¿—çº§åˆ«
LOG_LEVEL=info
>>>END FILE

>>>BEGIN FILE: backend/server.ts
import dotenv from 'dotenv'
import app from './src/app'
import { logger } from './src/utils/logger'

dotenv.config()

const PORT = process.env.PORT || 5174

app.listen(PORT, () => {
  logger.info(`ğŸš€ TapLive Backend server running on port ${PORT}`)
  logger.info(`ğŸ“Š Health check: http://localhost:${PORT}/healthz`)
  logger.info(`ğŸ“¡ API endpoint: http://localhost:${PORT}/api`)
  logger.info(`ğŸŒ Environment: ${process.env.NODE_ENV || 'development'}`)
})

// ä¼˜é›…å…³é—­
process.on('SIGTERM', () => {
  logger.info('SIGTERM received, shutting down gracefully')
  process.exit(0)
})

process.on('SIGINT', () => {
  logger.info('SIGINT received, shutting down gracefully')
  process.exit(0)
})
>>>END FILE

>>>BEGIN FILE: backend/src/app.ts
import express from 'express'
import helmet from 'helmet'
import morgan from 'morgan'
import { corsMiddleware } from './middleware/cors'
import { errorHandler } from './middleware/errorHandler'
import orderRoutes from './routes/orders'
import { logger } from './utils/logger'

const app = express()

// åŸºç¡€ä¸­é—´ä»¶
app.use(helmet())
app.use(corsMiddleware)
app.use(morgan('combined'))
app.use(express.json({ limit: '10mb' }))
app.use(express.urlencoded({ extended: true }))

// å¥åº·æ£€æŸ¥
app.get('/healthz', (req, res) => {
  res.status(200).json({
    status: 'ok',
    timestamp: new Date().toISOString(),
    service: 'TapLive Backend',
    version: '1.0.0',
    environment: process.env.NODE_ENV || 'development'
  })
})

// API è·¯ç”±
app.use('/api/orders', orderRoutes)

// 404 å¤„ç†
app.use('*', (req, res) => {
  logger.warn(`404 - Route not found: ${req.method} ${req.originalUrl}`)
  res.status(404).json({
    success: false,
    code: 'NOT_FOUND',
    message: `Route ${req.method} ${req.originalUrl} not found`
  })
})

// é”™è¯¯å¤„ç†ä¸­é—´ä»¶ï¼ˆå¿…é¡»æ”¾åœ¨æœ€åï¼‰
app.use(errorHandler)

export default app
>>>END FILE

>>>BEGIN FILE: backend/src/middleware/cors.ts
import cors from 'cors'

const corsOptions: cors.CorsOptions = {
  origin: [
    'http://localhost:5173',
    'http://localhost:3000',
    'https://replit.com',
    'https://*.replit.dev',
    process.env.FRONTEND_URL
  ].filter(Boolean),
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'],
  allowedHeaders: [
    'Content-Type',
    'Authorization',
    'X-Requested-With',
    'Accept',
    'Origin'
  ],
  credentials: true,
  maxAge: 86400 // 24 hours
}

export const corsMiddleware = cors(corsOptions)
>>>END FILE

>>>BEGIN FILE: backend/src/middleware/errorHandler.ts
import { Request, Response, NextFunction } from 'express'
import { logger } from '../utils/logger'

export interface AppError extends Error {
  statusCode?: number
  code?: string
  isOperational?: boolean
}

export const errorHandler = (
  error: AppError,
  req: Request,
  res: Response,
  next: NextFunction
) => {
  const statusCode = error.statusCode || 500
  const code = error.code || 'INTERNAL_SERVER_ERROR'
  const message = error.message || 'Internal server error'

  // è®°å½•é”™è¯¯
  logger.error(`Error ${statusCode} - ${code}: ${message}`, {
    url: req.originalUrl,
    method: req.method,
    stack: error.stack,
    body: req.body
  })

  // å‘é€é”™è¯¯å“åº”
  res.status(statusCode).json({
    success: false,
    code,
    message,
    ...(process.env.NODE_ENV === 'development' && { stack: error.stack })
  })
}

export const createError = (
  message: string, 
  statusCode: number = 500, 
  code: string = 'INTERNAL_SERVER_ERROR'
): AppError => {
  const error = new Error(message) as AppError
  error.statusCode = statusCode
  error.code = code
  error.isOperational = true
  return error
}
>>>END FILE

>>>BEGIN FILE: backend/src/models/Order.ts
export type OrderStatus = 'pending' | 'open' | 'accepted' | 'live' | 'done' | 'cancelled'

export type OrderType = 'single' | 'group'

export interface Location {
  latitude: number
  longitude: number
  address?: string
}

export interface Order {
  id: string
  title: string
  description: string
  type: OrderType
  status: OrderStatus
  location: Location
  price: number
  maxParticipants?: number // æ‹¼å›¢æ¨¡å¼çš„æœ€å¤§å‚ä¸äººæ•°
  currentParticipants: number
  scheduledAt: string // ISO 8601 æ—¥æœŸæ—¶é—´
  duration: number // ç›´æ’­æ—¶é•¿ï¼ˆåˆ†é’Ÿï¼‰
  liveUrl?: string // ç›´æ’­é“¾æ¥
  replayUrl?: string // å›æ”¾é“¾æ¥
  creatorId?: string // åˆ›å»ºè€…IDï¼ˆç™»å½•ç”¨æˆ·ï¼‰
  providerId?: string // æœåŠ¡æä¾›è€…ID
  tags?: string[]
  createdAt: string
  updatedAt: string
}

export interface CreateOrderRequest {
  title: string
  description: string
  type: OrderType
  location: Location
  price: number
  maxParticipants?: number
  scheduledAt: string
  duration: number
  tags?: string[]
}

export interface UpdateOrderRequest {
  status?: OrderStatus
  providerId?: string
  liveUrl?: string
  replayUrl?: string
}
>>>END FILE

>>>BEGIN FILE: backend/src/services/orderService.ts
import { Order, CreateOrderRequest, UpdateOrderRequest, OrderStatus } from '../models/Order'
import { v4 as uuidv4 } from 'uuid'
import { createError } from '../middleware/errorHandler'

// å†…å­˜å­˜å‚¨ï¼ˆç”Ÿäº§ç¯å¢ƒåº”ä½¿ç”¨æ•°æ®åº“ï¼‰
class OrderService {
  private orders: Order[] = []

  constructor() {
    // åˆå§‹åŒ–ä¸€äº›æµ‹è¯•æ•°æ®
    this.initTestData()
  }

  private initTestData(): void {
    const testOrders: Order[] = [
      {
        id: uuidv4(),
        title: 'é¦™æ¸¯ç»´å¤šåˆ©äºšæ¸¯å¤œæ™¯ç›´æ’­',
        description: 'å¸¦æ‚¨æ¬£èµé¦™æ¸¯ç»´å¤šåˆ©äºšæ¸¯çš„ç¾ä¸½å¤œæ™¯ï¼ŒåŒ…æ‹¬ç¯å…‰ç§€è¡¨æ¼”',
        type: 'single',
        status: 'open',
        location: {
          latitude: 22.2944,
          longitude: 114.1691,
          address: 'é¦™æ¸¯ç»´å¤šåˆ©äºšæ¸¯'
        },
        price: 299,
        currentParticipants: 1,
        scheduledAt: new Date(Date.now() + 2 * 60 * 60 * 1000).toISOString(), // 2å°æ—¶å
        duration: 60,
        tags: ['å¤œæ™¯', 'é¦™æ¸¯', 'ç»´å¤šåˆ©äºšæ¸¯'],
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
      },
      {
        id: uuidv4(),
        title: 'ä¸œäº¬æ¶©è°·åå­—è·¯å£å®å†µ',
        description: 'å®æ—¶å±•ç¤ºä¸œäº¬æœ€ç¹å¿™çš„æ¶©è°·åå­—è·¯å£äººæ½®',
        type: 'group',
        status: 'pending',
        location: {
          latitude: 35.6598,
          longitude: 139.7006,
          address: 'æ—¥æœ¬ä¸œäº¬æ¶©è°·åå­—è·¯å£'
        },
        price: 99,
        maxParticipants: 10,
        currentParticipants: 3,
        scheduledAt: new Date(Date.now() + 4 * 60 * 60 * 1000).toISOString(), // 4å°æ—¶å
        duration: 30,
        tags: ['ä¸œäº¬', 'æ¶©è°·', 'è¡—æ™¯'],
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
      }
    ]

    this.orders = testOrders
  }

  async getAllOrders(): Promise<Order[]> {
    // æŒ‰åˆ›å»ºæ—¶é—´å€’åºæ’åˆ—
    return this.orders.sort((a, b) => 
      new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()
    )
  }

  async getOrderById(id: string): Promise<Order | null> {
    return this.orders.find(order => order.id === id) || null
  }

  async createOrder(orderData: CreateOrderRequest, creatorId?: string): Promise<Order> {
    // éªŒè¯æ•°æ®
    if (!orderData.title || orderData.title.trim().length < 3) {
      throw createError('è®¢å•æ ‡é¢˜è‡³å°‘éœ€è¦3ä¸ªå­—ç¬¦', 400, 'INVALID_TITLE')
    }

    if (!orderData.location || !orderData.location.latitude || !orderData.location.longitude) {
      throw createError('å¿…é¡»æä¾›æœ‰æ•ˆçš„ä½ç½®ä¿¡æ¯', 400, 'INVALID_LOCATION')
    }

    if (orderData.price <= 0) {
      throw createError('è®¢å•ä»·æ ¼å¿…é¡»å¤§äº0', 400, 'INVALID_PRICE')
    }

    if (orderData.type === 'group' && (!orderData.maxParticipants || orderData.maxParticipants < 2)) {
      throw createError('æ‹¼å›¢è®¢å•æœ€å¤§å‚ä¸äººæ•°è‡³å°‘ä¸º2äºº', 400, 'INVALID_MAX_PARTICIPANTS')
    }

    const scheduledTime = new Date(orderData.scheduledAt)
    if (scheduledTime <= new Date()) {
      throw createError('ç›´æ’­æ—¶é—´å¿…é¡»æ˜¯æœªæ¥æ—¶é—´', 400, 'INVALID_SCHEDULED_TIME')
    }

    const newOrder: Order = {
      id: uuidv4(),
      ...orderData,
      status: orderData.type === 'single' ? 'open' : 'pending',
      currentParticipants: 1,
      creatorId,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    }

    this.orders.push(newOrder)
    return newOrder
  }

  async updateOrder(id: string, updateData: UpdateOrderRequest): Promise<Order> {
    const orderIndex = this.orders.findIndex(order => order.id === id)
    
    if (orderIndex === -1) {
      throw createError('è®¢å•ä¸å­˜åœ¨', 404, 'ORDER_NOT_FOUND')
    }

    const order = this.orders[orderIndex]

    // éªŒè¯çŠ¶æ€è½¬æ¢
    if (updateData.status) {
      this.validateStatusTransition(order.status, updateData.status)
    }

    const updatedOrder: Order = {
      ...order,
      ...updateData,
      updatedAt: new Date().toISOString()
    }

    this.orders[orderIndex] = updatedOrder
    return updatedOrder
  }

  async deleteOrder(id: string): Promise<void> {
    const orderIndex = this.orders.findIndex(order => order.id === id)
    
    if (orderIndex === -1) {
      throw createError('è®¢å•ä¸å­˜åœ¨', 404, 'ORDER_NOT_FOUND')
    }

    this.orders.splice(orderIndex, 1)
  }

  private validateStatusTransition(currentStatus: OrderStatus, newStatus: OrderStatus): void {
    const validTransitions: Record<OrderStatus, OrderStatus[]> = {
      'pending': ['open', 'cancelled'],
      'open': ['accepted', 'cancelled'],
      'accepted': ['live', 'cancelled'],
      'live': ['done'],
      'done': [],
      'cancelled': []
    }

    if (!validTransitions[currentStatus].includes(newStatus)) {
      throw createError(
        `æ— æ³•ä»çŠ¶æ€ ${currentStatus} è½¬æ¢åˆ° ${newStatus}`,
        400,
        'INVALID_STATUS_TRANSITION'
      )
    }
  }

  async getOrdersByStatus(status: OrderStatus): Promise<Order[]> {
    return this.orders.filter(order => order.status === status)
  }

  async getOrdersByLocation(latitude: number, longitude: number, radiusKm: number = 10): Promise<Order[]> {
    // ç®€å•çš„è·ç¦»è®¡ç®—ï¼ˆç”Ÿäº§ç¯å¢ƒåº”ä½¿ç”¨æ›´ç²¾ç¡®çš„åœ°ç†è®¡ç®—ï¼‰
    return this.orders.filter(order => {
      const latDiff = Math.abs(order.location.latitude - latitude)
      const lngDiff = Math.abs(order.location.longitude - longitude)
      const roughDistance = Math.sqrt(latDiff * latDiff + lngDiff * lngDiff) * 111 // ç²—ç•¥è½¬æ¢ä¸ºå…¬é‡Œ
      return roughDistance <= radiusKm
    })
  }
}

export const orderService = new OrderService()
>>>END FILE

>>>BEGIN FILE: backend/src/controllers/orderController.ts
import { Request, Response, NextFunction } from 'express'
import { orderService } from '../services/orderService'
import { CreateOrderRequest, UpdateOrderRequest, OrderStatus } from '../models/Order'
import Joi from 'joi'
import { createError } from '../middleware/errorHandler'
import { logger } from '../utils/logger'

// éªŒè¯schemas
const createOrderSchema = Joi.object({
  title: Joi.string().min(3).max(100).required(),
  description: Joi.string().min(10).max(500).required(),
  type: Joi.string().valid('single', 'group').required(),
  location: Joi.object({
    latitude: Joi.number().min(-90).max(90).required(),
    longitude: Joi.number().min(-180).max(180).required(),
    address: Joi.string().max(200).optional()
  }).required(),
  price: Joi.number().min(1).max(10000).required(),
  maxParticipants: Joi.number().min(2).max(100).when('type', {
    is: 'group',
    then: Joi.required(),
    otherwise: Joi.optional()
  }),
  scheduledAt: Joi.string().isoDate().required(),
  duration: Joi.number().min(10).max(480).required(), // 10åˆ†é’Ÿåˆ°8å°æ—¶
  tags: Joi.array().items(Joi.string().max(20)).max(10).optional()
})

const updateOrderSchema = Joi.object({
  status: Joi.string().valid('pending', 'open', 'accepted', 'live', 'done', 'cancelled').optional(),
  providerId: Joi.string().uuid().optional(),
  liveUrl: Joi.string().uri().optional(),
  replayUrl: Joi.string().uri().optional()
})

export class OrderController {
  async getAllOrders(req: Request, res: Response, next: NextFunction) {
    try {
      const { status, latitude, longitude, radius } = req.query

      let orders
      
      if (status && typeof status === 'string') {
        orders = await orderService.getOrdersByStatus(status as OrderStatus)
      } else if (latitude && longitude && typeof latitude === 'string' && typeof longitude === 'string') {
        const lat = parseFloat(latitude)
        const lng = parseFloat(longitude)
        const radiusKm = radius ? parseFloat(radius as string) : 10
        orders = await orderService.getOrdersByLocation(lat, lng, radiusKm)
      } else {
        orders = await orderService.getAllOrders()
      }

      logger.info(`Retrieved ${orders.length} orders`)

      res.status(200).json({
        success: true,
        data: orders,
        meta: {
          total: orders.length,
          timestamp: new Date().toISOString()
        }
      })
    } catch (error) {
      next(error)
    }
  }

  async getOrderById(req: Request, res: Response, next: NextFunction) {
    try {
      const { id } = req.params

      if (!id) {
        throw createError('è®¢å•IDæ˜¯å¿…éœ€çš„', 400, 'MISSING_ORDER_ID')
      }

      const order = await orderService.getOrderById(id)

      if (!order) {
        throw createError('è®¢å•ä¸å­˜åœ¨', 404, 'ORDER_NOT_FOUND')
      }

      logger.info(`Retrieved order: ${id}`)

      res.status(200).json({
        success: true,
        data: order
      })
    } catch (error) {
      next(error)
    }
  }

  async createOrder(req: Request, res: Response, next: NextFunction) {
    try {
      const { error, value } = createOrderSchema.validate(req.body, { abortEarly: false })

      if (error) {
        const errorMessages = error.details.map(detail => detail.message).join(', ')
        throw createError(`æ•°æ®éªŒè¯å¤±è´¥: ${errorMessages}`, 400, 'VALIDATION_ERROR')
      }

      const orderData: CreateOrderRequest = value
      
      // è¿™é‡Œå¯ä»¥ä»è®¤è¯ä¸­é—´ä»¶è·å–ç”¨æˆ·IDï¼Œ