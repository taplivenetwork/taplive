{
  "include": ["client/src/**/*", "shared/**/*", "server/**/*"],
  "exclude": ["node_modules", "build", "dist", "**/*.test.ts"],
  "compilerOptions": {
    "incremental": true,
    "tsBuildInfoFile": "./node_modules/typescript/tsbuildinfo",
    "noEmit": true,
    "module": "ESNext",
    "strict": true,
    "lib": ["esnext", "dom", "dom.iterable"],
    "jsx": "preserve",
    "esModuleInterop": true,
    "skipLibCheck": true,
    "allowImportingTsExtensions": true,
    "moduleResolution": "bundler",
    "baseUrl": ".",
    "types": ["node", "vite/client"],
    "paths": {
      "@/*": ["./client/src/*"],
      "@shared/*": ["./shared/*"]
    }
  }
}
# === TapLive MVP quick patch & run ===
set -e

# 1) 覆盖 server/storage.ts
cat > server/storage.ts <<'TS'
import { randomUUID } from "crypto";

export type OrderStatus = "pending" | "open" | "accepted" | "live" | "done" | "cancelled";
export type OrderType = "single" | "group";

export interface Order {
  id: string;
  title: string;
  description?: string | null;
  type: OrderType;
  status: OrderStatus;
  latitude: number;
  longitude: number;
  price: number;
  category?: string | null;
  tags: string[];
  scheduledAt?: string | null;
  duration?: number | null;
  providerId?: string | null;
  maxParticipants?: number | null;
  currentParticipants: number;
  participants?: Array<{ userId: string; contributedAmount?: number }>;
  liveUrl?: string | null;
  replayUrl?: string | null;
  createdAt: string;
  updatedAt: string;
}

export interface OrderCreateInput {
  title: string;
  description?: string | null;
  type: OrderType;
  latitude: number;
  longitude: number;
  price: number;
  category?: string | null;
  tags?: string[];
  scheduledAt?: string | null;
  duration?: number | null;
  maxParticipants?: number | null;
}

export interface OrderUpdateInput extends Partial<OrderCreateInput> {
  status?: OrderStatus;
  providerId?: string | null;
  liveUrl?: string | null;
  replayUrl?: string | null;
}

export interface ListFilter {
  status?: OrderStatus;
  latitude?: number;
  longitude?: number;
  radiusKm?: number;
  q?: string;
  tag?: string;
}

export interface IStorage {
  createOrder(input: OrderCreateInput): Promise<Order>;
  getOrderById(id: string): Promise<Order | undefined>;
  listOrders(filter?: ListFilter): Promise<Order[]>;
  updateOrder(id: string, patch: OrderUpdateInput): Promise<Order | undefined>;
  deleteOrder(id: string): Promise<boolean>;

  acceptOrder(id: string, providerId: string): Promise<Order | undefined>;
  joinGroupOrder(id: string, userId: string, contributedAmount?: number): Promise<Order | undefined>;
}

function nowISO() {
  return new Date().toISOString();
}

function haversineKm(lat1: number, lon1: number, lat2: number, lon2: number) {
  const toRad = (d: number) => (d * Math.PI) / 180;
  const R = 6371;
  const dLat = toRad(lat2 - lat1);
  const dLon = toRad(lon2 - lon1);
  const a =
    Math.sin(dLat / 2) ** 2 +
    Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon / 2) ** 2;
  return 2 * R * Math.asin(Math.sqrt(a));
}

export class MemoryStorage implements IStorage {
  private orders = new Map<string, Order>();

  constructor() {
    const seed: Order[] = [
      {
        id: randomUUID(),
        title: "Eiffel Tower live walk",
        description: "15-min live walk around Champ de Mars",
        type: "single",
        status: "open",
        latitude: 48.8584,
        longitude: 2.2945,
        price: 12.5,
        category: "sightseeing",
        tags: ["paris", "tower", "walk"],
        scheduledAt: null,
        duration: 15,
        providerId: null,
        maxParticipants: null,
        currentParticipants: 0,
        participants: [],
        liveUrl: null,
        replayUrl: null,
        createdAt: nowISO(),
        updatedAt: nowISO(),
      },
      {
        id: randomUUID(),
        title: "Times Square group order",
        description: "Group AA order, 10-min street view",
        type: "group",
        status: "open",
        latitude: 40.758,
        longitude: -73.9855,
        price: 10,
        category: "city",
        tags: ["nyc", "street"],
        scheduledAt: null,
        duration: 10,
        providerId: null,
        maxParticipants: 5,
        currentParticipants: 2,
        participants: [{ userId: "u_demo_1", contributedAmount: 2 }, { userId: "u_demo_2", contributedAmount: 2 }],
        liveUrl: null,
        replayUrl: null,
        createdAt: nowISO(),
        updatedAt: nowISO(),
      },
    ];
    seed.forEach((o) => this.orders.set(o.id, o));
  }

  async createOrder(input: OrderCreateInput): Promise<Order> {
    const id = randomUUID();
    const order: Order = {
      id,
      title: input.title,
      description: input.description ?? null,
      type: input.type,
      status: "open",
      latitude: Number(input.latitude),
      longitude: Number(input.longitude),
      price: Number(input.price),
      category: input.category ?? null,
      tags: input.tags ?? [],
      scheduledAt: input.scheduledAt ?? null,
      duration: input.duration ?? null,
      providerId: null,
      maxParticipants: input.type === "group" ? input.maxParticipants ?? 2 : null,
      currentParticipants: 0,
      participants: [],
      liveUrl: null,
      replayUrl: null,
      createdAt: nowISO(),
      updatedAt: nowISO(),
    };
    this.orders.set(id, order);
    return order;
  }

  async getOrderById(id: string) {
    return this.orders.get(id);
  }

  async listOrders(filter?: ListFilter) {
    let arr = [...this.orders.values()];

    if (filter?.status) arr = arr.filter((o) => o.status === filter.status);
    if (filter?.q) {
      const q = filter.q.toLowerCase();
      arr = arr.filter(
        (o) =>
          o.title.toLowerCase().includes(q) ||
          (o.description ?? "").toLowerCase().includes(q)
      );
    }
    if (filter?.tag) {
      arr = arr.filter((o) => o.tags.includes(filter.tag!));
    }
    if (
      typeof filter?.latitude === "number" &&
      typeof filter?.longitude === "number" &&
      typeof filter?.radiusKm === "number"
    ) {
      arr = arr.filter((o) => {
        const d = haversineKm(filter.latitude!, filter.longitude!, o.latitude, o.longitude);
        return d <= filter.radiusKm!;
      });
    }
    arr.sort((a, b) => (a.updatedAt < b.updatedAt ? 1 : -1));
    return arr;
  }

  async updateOrder(id: string, patch: OrderUpdateInput) {
    const cur = this.orders.get(id);
    if (!cur) return undefined;
    const next: Order = {
      ...cur,
      ...patch,
      latitude: patch.latitude !== undefined ? Number(patch.latitude) : cur.latitude,
      longitude: patch.longitude !== undefined ? Number(patch.longitude) : cur.longitude,
      price: patch.price !== undefined ? Number(patch.price) : cur.price,
      tags: patch.tags ?? cur.tags,
      updatedAt: nowISO(),
    };
    this.orders.set(id, next);
    return next;
  }

  async deleteOrder(id: string) {
    return this.orders.delete(id);
  }

  async acceptOrder(id: string, providerId: string) {
    const cur = this.orders.get(id);
    if (!cur) return undefined;
    if (!["open", "pending"].includes(cur.status)) return cur;
    const next = { ...cur, status: "accepted" as OrderStatus, providerId, updatedAt: nowISO() };
    this.orders.set(id, next);
    return next;
  }

  async joinGroupOrder(id: string, userId: string, contributedAmount?: number) {
    const cur = this.orders.get(id);
    if (!cur) return undefined;
    if (cur.type !== "group") return cur;
    if (cur.maxParticipants && cur.currentParticipants >= cur.maxParticipants) return cur;

    const already = (cur.participants ?? []).some((p) => p.userId === userId);
    if (already) return cur;

    const participants = [...(cur.participants ?? []), { userId, contributedAmount }];
    let status: OrderStatus = cur.status;
    const currentParticipants = (cur.currentParticipants ?? 0) + 1;

    if (cur.maxParticipants && currentParticipants >= cur.maxParticipants && cur.status === "open") {
      status = "open";
    }

    const next: Order = {
      ...cur,
      participants,
      currentParticipants,
      status,
      updatedAt: nowISO(),
    };
    this.orders.set(id, next);
    return next;
  }
}

export const storage: IStorage = new MemoryStorage();
TS

# 2) 覆盖 server/vite.ts
cat > server/vite.ts <<'TS'
import type { Express } from "express";
import path from "path";
import fs from "fs";
import { fileURLToPath } from "url";

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const CLIENT_DIST = path.resolve(__dirname, "../client/dist");
const CLIENT_INDEX = path.resolve(CLIENT_DIST, "index.html");

export async function setupVite(app: Express) {
  const vite = await (await import("vite")).createServer({
    root: path.resolve(__dirname, "../client"),
    server: { middlewareMode: true },
    appType: "custom",
  });
  app.use(vite.middlewares);
}

export function serveStatic(app: Express) {
  const express = require("express");
  app.use(express.static(CLIENT_DIST));

  app.use("*", (_req, res) => {
    if (fs.existsSync(CLIENT_INDEX)) {
      res.sendFile(CLIENT_INDEX);
    } else {
      res.status(200).send("Client not built. Run `npm run build`.");
    }
  });
}
TS

# 3) 覆盖 server/index.ts
cat > server/index.ts <<'TS'
import express from "express";
import cors from "cors";
import morgan from "morgan";
import { registerRoutes } from "./routes";
import { setupVite, serveStatic } from "./vite";

const app = express();

app.use(express.json());
app.use(cors());
app.use(morgan("tiny"));

await registerRoutes(app);

app.use((_req, res) => {
  res.status(404).json({ success: false, message: "Not found" });
});

app.use((err: any, _req: any, res: any, _next: any) => {
  console.error(err);
  res.status(500).json({ success: false, message: "Internal Server Error" });
});

const isProd = process.env.NODE_ENV === "production";

if (!isProd) {
  await setupVite(app);
} else {
  serveStatic(app);
}

const PORT = Number(process.env.PORT || 5000);
const HOST = "0.0.0.0";

app.listen(PORT, HOST, () => {
  console.log(`Server listening on http://${HOST}:${PORT} (NODE_ENV=${process.env.NODE_ENV || "development"})`);
});
TS

# 4) 覆盖 server/routes.ts
cat > server/routes.ts <<'TS'
import type { Express, Response } from "express";
import { storage } from "./storage";

function ok(res: Response, data: any, meta?: any) {
  return res.json({ success: true, data, meta });
}
function bad(res: Response, code: number, message: string) {
  return res.status(code).json({ success: false, message });
}

export async function registerRoutes(app: Express) {
  app.get("/healthz", (_req, res) => ok(res, { up: true, ts: Date.now() }));

  app.get("/api/orders", async (req, res) => {
    const { status, latitude, longitude, radius, q, tag } = req.query as Record<string, string | undefined>;
    const filter = {
      status: status as any,
      latitude: latitude ? Number(latitude) : undefined,
      longitude: longitude ? Number(longitude) : undefined,
      radiusKm: radius ? Number(radius) : undefined,
      q,
      tag,
    };
    const list = await storage.listOrders(filter);
    return ok(res, list);
  });

  app.get("/api/orders/:id", async (req, res) => {
    const one = await storage.getOrderById(req.params.id);
    if (!one) return bad(res, 404, "Order not found");
    return ok(res, one);
  });

  app.post("/api/orders", async (req, res) => {
    try {
      const { title, description, type, latitude, longitude, price, category, tags, scheduledAt, duration, maxParticipants } = req.body || {};
      if (!title || !type || latitude === undefined || longitude === undefined || price === undefined) {
        return bad(res, 400, "Missing required fields: title, type, latitude, longitude, price");
      }
      if (type === "group" && (!maxParticipants || maxParticipants < 2)) {
        return bad(res, 400, "Group order requires maxParticipants >= 2");
      }
      const created = await storage.createOrder({
        title,
        description,
        type,
        latitude: Number(latitude),
        longitude: Number(longitude),
        price: Number(price),
        category,
        tags,
        scheduledAt,
        duration,
        maxParticipants,
      });
      return ok(res, created);
    } catch (e: any) {
      console.error(e);
      return bad(res, 500, e?.message || "Failed to create order");
    }
  });

  app.patch("/api/orders/:id", async (req, res) => {
    try {
      const patched = await storage.updateOrder(req.params.id, req.body || {});
      if (!patched) return bad(res, 404, "Order not found");
      return ok(res, patched);
    } catch (e: any) {
      console.error(e);
      return bad(res, 500, e?.message || "Failed to update order");
    }
  });

  app.delete("/api/orders/:id", async (req, res) => {
    const okDel = await storage.deleteOrder(req.params.id);
    if (!okDel) return bad(res, 404, "Order not found");
    return ok(res, { deleted: true });
  });

  app.post("/api/orders/:id/accept", async (req, res) => {
    const { providerId } = req.body || {};
    if (!providerId) return bad(res, 400, "providerId required");
    const updated = await storage.acceptOrder(req.params.id, providerId);
    if (!updated) return bad(res, 404, "Order not found");
    return ok(res, updated);
  });

  app.post("/api/orders/:id/join", async (req, res) => {
    const { userId, contributedAmount } = req.body || {};
    if (!userId) return bad(res, 400, "userId required");
    const updated = await storage.joinGroupOrder(req.params.id, userId, contributedAmount);
    if (!updated) return bad(res, 404, "Order not found");
    return ok(res, updated);
  });
}
TS

# 5) 安装/清理依赖并启动
npm i
npm remove passport connect-pg-simple memorystore || true
npm run dev
